import { AnalysisResult, GraphNode } from '../types';

/**
 * Export analysis data as JSON file
 */
export const exportAsJSON = (analysis: AnalysisResult, filename: string = 'teliclens-analysis.json') => {
  const dataStr = JSON.stringify(analysis, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  downloadBlob(dataBlob, filename);
};

/**
 * Export analysis as formatted text report
 */
export const exportAsTextReport = (analysis: AnalysisResult, filename: string = 'teliclens-report.txt') => {
  let report = '';

  // Header
  report += '═══════════════════════════════════════════════════════════\n';
  report += '                     TELIC LENS ANALYSIS REPORT            \n';
  report += '═══════════════════════════════════════════════════════════\n\n';
  report += `Generated: ${new Date().toLocaleString()}\n\n`;

  // Summary
  report += '## EXECUTIVE SUMMARY\n';
  report += '─────────────────────────────────────────────────────────\n';
  report += analysis.summary + '\n\n';

  // Causal Analysis
  report += '## CAUSAL ANALYSIS (Mechanistic View)\n';
  report += '─────────────────────────────────────────────────────────\n\n';

  const files = analysis.nodes.filter(n => n.type === 'file');
  const functions = analysis.nodes.filter(n => n.type === 'function');
  const dataStores = analysis.nodes.filter(n => n.type === 'data');

  report += `Files: ${files.length}\n`;
  files.forEach(f => {
    report += `  - ${f.label}: ${f.description || 'No description'}\n`;
  });
  report += '\n';

  report += `Functions: ${functions.length}\n`;
  functions.forEach(fn => {
    report += `  - ${fn.label}\n`;
    report += `    Description: ${fn.description || 'No description'}\n`;

    // Find dependencies
    const deps = analysis.edges
      .filter(e => e.source === fn.id && (e.type === 'dependency' || e.type === 'flow'))
      .map(e => analysis.nodes.find(n => n.id === e.target)?.label)
      .filter(Boolean);

    if (deps.length > 0) {
      report += `    Depends on: ${deps.join(', ')}\n`;
    }
    report += '\n';
  });

  report += `Data Stores: ${dataStores.length}\n`;
  dataStores.forEach(d => {
    report += `  - ${d.label}: ${d.description || 'No description'}\n`;
  });
  report += '\n';

  // Telic Analysis
  report += '## TELIC ANALYSIS (Intentionality View)\n';
  report += '─────────────────────────────────────────────────────────\n\n';

  const intents = analysis.nodes.filter(n => n.type === 'intent');

  report += `System-Level Intents: ${intents.length}\n\n`;

  intents.forEach(intent => {
    report += `### ${intent.label}\n`;
    report += `${intent.description}\n\n`;

    // Find functions serving this intent
    const servingFunctions = analysis.edges
      .filter(e => e.target === intent.id && e.type === 'serves_intent')
      .map(e => analysis.nodes.find(n => n.id === e.source))
      .filter(Boolean) as GraphNode[];

    if (servingFunctions.length > 0) {
      report += 'Implemented by:\n';
      servingFunctions.forEach(fn => {
        report += `  - ${fn.label}\n`;
        report += `    Purpose: ${fn.intent || 'Not specified'}\n`;
      });
      report += '\n';
    }
  });

  // Security Check
  report += '## SECURITY ANALYSIS\n';
  report += '─────────────────────────────────────────────────────────\n\n';

  // Check for orphaned functions (no intent mapping)
  const orphanedFunctions = functions.filter(fn => {
    return !analysis.edges.some(e => e.source === fn.id && e.type === 'serves_intent');
  });

  if (orphanedFunctions.length > 0) {
    report += '⚠️  ORPHANED FUNCTIONS (No clear purpose mapped):\n';
    orphanedFunctions.forEach(fn => {
      report += `  - ${fn.label}: ${fn.description}\n`;
    });
    report += '\n';
  } else {
    report += '✓ All functions have clear intentional mappings\n\n';
  }

  // Check for intent coverage
  if (intents.length === 0) {
    report += '⚠️  WARNING: No system-level intents identified\n';
    report += '   This may indicate lack of clear purpose or incomplete analysis\n\n';
  } else {
    report += `✓ ${intents.length} system-level intents identified\n\n`;
  }

  // Stats
  report += '## STATISTICS\n';
  report += '─────────────────────────────────────────────────────────\n';
  report += `Total Nodes: ${analysis.nodes.length}\n`;
  report += `Total Edges: ${analysis.edges.length}\n`;
  report += `Files: ${files.length}\n`;
  report += `Functions: ${functions.length}\n`;
  report += `Data Stores: ${dataStores.length}\n`;
  report += `Intents: ${intents.length}\n`;
  report += `Orphaned Functions: ${orphanedFunctions.length}\n`;

  // Footer
  report += '\n═══════════════════════════════════════════════════════════\n';
  report += '           Generated by TelicLens - AI Code Inspector     \n';
  report += '═══════════════════════════════════════════════════════════\n';

  const dataBlob = new Blob([report], { type: 'text/plain' });
  downloadBlob(dataBlob, filename);
};

/**
 * Export analysis as Markdown report
 */
export const exportAsMarkdown = (analysis: AnalysisResult, filename: string = 'teliclens-report.md') => {
  let report = '';

  // Header
  report += '# TelicLens Analysis Report\n\n';
  report += `**Generated:** ${new Date().toLocaleString()}\n\n`;
  report += '---\n\n';

  // Summary
  report += '## Executive Summary\n\n';
  report += analysis.summary + '\n\n';

  // Causal Analysis
  report += '## Causal Analysis (Mechanistic View)\n\n';

  const files = analysis.nodes.filter(n => n.type === 'file');
  const functions = analysis.nodes.filter(n => n.type === 'function');
  const dataStores = analysis.nodes.filter(n => n.type === 'data');

  report += '### Files\n\n';
  files.forEach(f => {
    report += `- **${f.label}**: ${f.description || 'No description'}\n`;
  });
  report += '\n';

  report += '### Functions\n\n';
  functions.forEach(fn => {
    report += `#### ${fn.label}\n\n`;
    report += `${fn.description || 'No description'}\n\n`;

    // Find dependencies
    const deps = analysis.edges
      .filter(e => e.source === fn.id && (e.type === 'dependency' || e.type === 'flow'))
      .map(e => analysis.nodes.find(n => n.id === e.target)?.label)
      .filter(Boolean);

    if (deps.length > 0) {
      report += `**Dependencies:** ${deps.join(', ')}\n\n`;
    }
  });

  report += '### Data Stores\n\n';
  dataStores.forEach(d => {
    report += `- **${d.label}**: ${d.description || 'No description'}\n`;
  });
  report += '\n';

  // Telic Analysis
  report += '## Telic Analysis (Intentionality View)\n\n';

  const intents = analysis.nodes.filter(n => n.type === 'intent');

  intents.forEach(intent => {
    report += `### ${intent.label}\n\n`;
    report += `${intent.description}\n\n`;

    // Find functions serving this intent
    const servingFunctions = analysis.edges
      .filter(e => e.target === intent.id && e.type === 'serves_intent')
      .map(e => analysis.nodes.find(n => n.id === e.source))
      .filter(Boolean) as GraphNode[];

    if (servingFunctions.length > 0) {
      report += '**Implemented by:**\n\n';
      servingFunctions.forEach(fn => {
        report += `- **${fn.label}**: ${fn.intent || 'Not specified'}\n`;
      });
      report += '\n';
    }
  });

  // Security Check
  report += '## Security Analysis\n\n';

  const orphanedFunctions = functions.filter(fn => {
    return !analysis.edges.some(e => e.source === fn.id && e.type === 'serves_intent');
  });

  if (orphanedFunctions.length > 0) {
    report += '### ⚠️ Orphaned Functions\n\n';
    report += 'The following functions have no clear purpose mapping:\n\n';
    orphanedFunctions.forEach(fn => {
      report += `- **${fn.label}**: ${fn.description}\n`;
    });
    report += '\n';
  } else {
    report += '✅ All functions have clear intentional mappings\n\n';
  }

  if (intents.length === 0) {
    report += '⚠️ **WARNING:** No system-level intents identified. This may indicate lack of clear purpose or incomplete analysis.\n\n';
  }

  // Stats
  report += '## Statistics\n\n';
  report += `| Metric | Count |\n`;
  report += `|--------|-------|\n`;
  report += `| Total Nodes | ${analysis.nodes.length} |\n`;
  report += `| Total Edges | ${analysis.edges.length} |\n`;
  report += `| Files | ${files.length} |\n`;
  report += `| Functions | ${functions.length} |\n`;
  report += `| Data Stores | ${dataStores.length} |\n`;
  report += `| Intents | ${intents.length} |\n`;
  report += `| Orphaned Functions | ${orphanedFunctions.length} |\n`;

  report += '\n---\n\n';
  report += '*Generated by TelicLens - AI Code Inspector*\n';

  const dataBlob = new Blob([report], { type: 'text/markdown' });
  downloadBlob(dataBlob, filename);
};

/**
 * Helper function to trigger download
 */
function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
